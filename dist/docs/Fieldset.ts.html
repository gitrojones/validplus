

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> Fieldset.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="style.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">ValidPlus Validation Library</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/gitrojones/validplus"
                        >
                            Repo
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="Validatable.html">Validatable</a></li><li><a href="VPField.html">VPField</a></li><li><a href="VPFieldset.html">VPFieldset</a></li><li><a href="VPValidator.html">VPValidator</a></li></ul></div><div class="category"><h2>Interfaces</h2><h3>Interfaces</h3><ul><li><a href="CustomValidationRule.html">CustomValidationRule</a></li><li><a href="HTMLValidationRules.html">HTMLValidationRules</a></li><li><a href="InputFormatters.html">InputFormatters</a></li><li><a href="ValidationAttributes.html">ValidationAttributes</a></li><li><a href="ValidationLifecycle.html">ValidationLifecycle</a></li><li><a href="ValidationStrategies.html">ValidationStrategies</a></li><li><a href="ValidationStrategy.html">ValidationStrategy</a></li></ul></div><div class="category"><h2>Lib</h2><h3>Modules</h3><ul><li><a href="module-EventEmitter.html">EventEmitter</a></li></ul><h3>Classes</h3><ul><li><a href="DOMMessaging.html">DOMMessaging</a></li></ul></div><div class="category"><h2>Options</h2><h3>Classes</h3><ul><li><a href="FieldOptions.html">FieldOptions</a></li><li><a href="FieldsetOptions.html">FieldsetOptions</a></li><li><a href="ValidatableOptions.html">ValidatableOptions</a></li><li><a href="ValidatorOptions.html">ValidatorOptions</a></li></ul><h3>Interfaces</h3><ul><li><a href="VPFieldOptions.html">VPFieldOptions</a></li><li><a href="VPFieldsetOptions.html">VPFieldsetOptions</a></li><li><a href="VPOptions.html">VPOptions</a></li><li><a href="VPValidatorOptions.html">VPValidatorOptions</a></li></ul></div><div class="category"><h2>Types</h2><h3><a href="global.html">Global</a></h3></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>Fieldset.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import merge from 'lodash/merge'
import {hasAsync} from 'src/util/hasAsync'

import {VPFieldsetOptions, VPFieldOptions} from 'src/interfaces/VPOptions'
import {ValidationStrategy} from 'src/interfaces/validation/ValidationStrategy'

import {VPField} from 'src/Field'
import {Validatable} from 'src/Validatable'

import {FieldsetOptions} from 'src/models/VPOptions/FieldsetOptions'
import {toBoolean} from 'src/util/casts/toBoolean'
import {getAttributeIfSet} from 'src/util/getAttributeIfSet'
import IEVersion from 'src/util/IEVersion'

/**
 * VPFieldset Instance
 * @description
 * Fieldset instances are responsible for managing the relationship between fields. Fieldset instances
 * are capable of validating fields based upon a relationship, such as checkbox/radio fields being interdependent.
 * @example
 * // DOM Bindings, All Fields must validate true
 * &lt;div id="sample_fieldset" class="VPFieldset" vp-find>
 *   &lt;div class="VPField" vp-notify="false">
 *     &lt;input id="first-name" aria-label="First Name" name="first-name" type="text" required="required" />
 *   &lt;/div>
 *
 *   &lt;div class="VPField" vp-notify="false">
 *     &lt;input id="last-name" aria-label="Last Name" name="last-name" type="text" required="required" />
 *   &lt;/div>
 * &lt;/div>
 *
 * @example
 * // DOM Bindings, One field must be true
 * &lt;div id="sample_fieldset" class="VPFieldset" vp-strategy="one" vp-find>
 *  &lt;div class="VPField">
 *    &lt;label for="option_one">
 *      &lt;input id="option_one" name="option-one" type="radio" value="one" required="required" />
 *      Option #1
 *    &lt;/label>
 *  &lt;/div>
 *
 *  &lt;div class="VPField">
 *    &lt;label for="option_two">
 *      &lt;input id="option_two" name="option-two" type="radio" value="two" required="required" />
 *      Option #2
 *    &lt;/label>
 *  &lt;/div>
 *
 *  &lt;div class="VPField">
 *    &lt;label for="option_three">
 *      &lt;input id="option_three" name="option-three" type="radio" value="three" required="required" />
 *      Option #3
 *    &lt;/label>
 *  &lt;/div>
 * &lt;/div>
 * @example
 * // Programmic bindings
 * const fieldset = new VP.Fieldset(document.getElementById('sample_fieldset'), {
 *    ValidationStrategy: "one"
 * });
 * const option_one_field = new VP.Field(document.getElementsById('field_one'))
 * const option_two_field = new VP.Field(document.getElementsById('field_two'))
 * const option_three_field = new VP.Field(document.getElementsById('field_three'))
 * fieldset.addField(option_one_field);
 * fieldset.addField(option_two_field);
 * fieldset.addField(option_three_field);
 * @augments Validatable
 */
export class VPFieldset extends Validatable&lt;FieldsetOptions> {
  static Options = FieldsetOptions;

  $strategy: ValidationStrategy
  $fields: VPField[]
  $cached: VPField[]
  $canValidate: boolean
  $observer: MutationObserver | undefined

  get $visibleFields (): VPField[] {
    return this.$fields.filter((field: VPField) => {
      return this.isElementVisible(field.$element)
    })
  }

  constructor (element: HTMLElement, options: VPFieldsetOptions = {} as VPFieldsetOptions) {
    if (!(element instanceof HTMLElement)) throw new Error('[VPFieldset] Expected element');
    super(element, new VPFieldset.Options(merge({
      ValidationStrategy: getAttributeIfSet(element, 'vp-strategy', 'all'),
      FieldClass: getAttributeIfSet(element, 'vp-field-class', 'VPField'),
      FindFields: toBoolean(getAttributeIfSet(element, 'vp-find', false)),
    }, options) as VPFieldsetOptions, element));

    let validationStrategy = this.$options.ValidationStrategy;
    if (typeof validationStrategy === 'string') {
      validationStrategy = this.$strategies[validationStrategy];
    }
    if (typeof validationStrategy !== 'function') {
      throw new Error('[VPFieldset] Expected ValidationStrategy to be a function.')
    }
    this.$strategy = validationStrategy as ValidationStrategy;
    this.$fields = []
    this.$cached = []
    this.$canValidate = true;

    if (this.$options.FindFields) {
      this.findFields();
    }

    if (IEVersion === false || IEVersion >= 11) {
      this.$observer = new MutationObserver(this.$observe.bind(this));
      this.$observer.observe(element, {
        childList: true
      });
    }
  }

  get $isValid (): boolean | null { return super.$isValid; }
  set $isValid (isValid: boolean | null) {
    super.$isValid = isValid;
    if (!isValid &amp;&amp; this.$options.ScrollTo) this.scrollTo();

    this.$cached = [];
    this.$canValidate = true;
  }

  /**
   * If running a modern browser, VP will automatically
   * handle removing tracked nodes which are removed from the DOM.
   * If supporting sub IE11, you must do this yourself using the removeField
   * helpers defined on this instance.
   * @private
   */
  $observe (mutations: MutationRecord[]): void {
    for (const mutation of mutations) {
      if (mutation.type === 'childList') {
        const nodes = Array.from(mutation.removedNodes);
        while (nodes.length > 0) {
          const node = nodes.pop();
          if (!node) break;

          for (let i = 0, l = this.$fields.length; i &lt; l; i += 1) {
            const field = this.$fields[i];
            if (field.$element === node) {
              this.removeField(field);
              break;
            }
          }
          if (node.hasChildNodes()) nodes.push(...Array.from(node.childNodes));
        }
      }
    }
  }

  $fieldWatch (_e: Event, trigger: VPField): void {
    _e.stopPropagation()
    this.$cached.push(trigger)
    if (this.$canValidate) this.isValid()
  }

  $fieldRemove (_e: Event, field: VPField): void {
    _e.stopPropagation()
    this.removeField(field);
  }

  /**
   * Validation Cycle
   * @description
   * Standard Validation cycle for the Fieldset instance.
   *
   * + Validation will validate all tracked Fields
   * + Validation will return as either synchronous validation or asynchronous based on field responses.
   * + If Lazy, validation will stop at the first error
   * @returns (boolean|Promise.&lt;boolean>)
   */
  isValid (): (boolean | Promise&lt;boolean>) {
    this.$canValidate = false;
    this.clearMessages()
    const fields = this.$options.ValidateVisible ? this.$visibleFields : this.$fields;
    const fieldsetStatus: (boolean | Promise&lt;boolean>)[] = fields
      .map((field: VPField, index: number) => {
        console.debug('[VPFieldset] Validating field', field)

        // We already validated this, just take the value
        let valid: (boolean | Promise&lt;boolean>)
        if (this.$cached.indexOf(field) !== -1 &amp;&amp; typeof field.$valid === 'boolean') {
          console.debug('[VPFieldset] Cached Valid', index)
          valid = field.$valid
        }
        else {
          valid = field.isValid()
        }

        return valid
      })

    if (hasAsync(fieldsetStatus)) {
      const deferredFieldsetStatus = fieldsetStatus.map((status) =>
        Promise.resolve(status));

      return Promise.all(deferredFieldsetStatus)
        .then((statuses) => {
          console.debug('[VPFieldset] Resolved deferred', statuses)
          this.$isValid = this.$strategy(statuses, fields)
          return this.$isValid;
        })
        .catch((err) => {
          console.debug('[VPFieldset] Failed to resolve deferred FieldSet Status', err)
          this.$isValid = false
          return this.$isValid
        });
    } else {
      this.$isValid = this.$strategy(fieldsetStatus as boolean[], fields)
      return this.$isValid
    }
  }

  /**
   * Remove a tracked field from this fieldset
   * @param {VPField} field - Field instance to remove
   */
  removeField (field: VPField): (VPField | undefined) {
    console.debug('[VPFieldset] Removing field', field)

    const index = this.$fields.indexOf(field)
    if (index !== -1) {
      const field = this.$fields.splice(index, 1).pop()
      if (field) {
        field.clearMessages()
        field.removeMessageNode()
        field.removeEventListener('VPValidate', this.$fieldWatch.bind(this))
        field.removeEventListener('VPRemove', this.$fieldRemove.bind(this))
      }

      return field;
    }

    return;
  }

  /**
   * Add a field instance to be tracked
   * @param {VPField} field - Field to track
   * @param {number} [index] - Indicate the field order to track by
   */
  addField (field: VPField, index = this.$fields.length): void {
    console.debug('[VPFieldset] Adding field', field)
    this.$fields.splice(index, 0, field);

    field.addEventListener('VPValidate', this.$fieldWatch.bind(this))
    field.addEventListener('VPRemove', this.$fieldRemove.bind(this));
  }

  /**
   * Helper method for creating a new Field to automatically track
   * @param {HTMLElement} el - Field Element
   * @param {VPFieldOptions} options - Options to apply to the field instance
   */
  createField (el: HTMLElement, options: VPFieldOptions): VPField {
    if (!(el instanceof Element)) {
      throw new Error('[VPFieldset] Field Element must be a valid DOMElement.')
    }

    const field = new VPField(el, options)
    this.addField(field)
    return field
  }

  /**
   * Helper for automatically parsing child elements for Fields
   * @param {VPFieldOptions|VPFieldOptions[]} [fieldOptions] - Options to apply to the found fields. If array, options will apply based on index
   */
  findFields (fieldOptions: (VPFieldOptions | VPFieldOptions[]) = {} as VPFieldOptions) : void {
    const fields = Array.from(this.$element.getElementsByClassName(this.$options.FieldClass))
    if (fields.length === 0) {
      console.debug('[VPFieldset] Failed to find child fields')
      return;
    }

    fields
      .forEach((field: Element, index: number) => {
      if (!this.$fields.every((f) => f.$element !== field)) return;
      const options: VPFieldOptions = Array.isArray(fieldOptions) ? fieldOptions[index] : fieldOptions
      const _field = new VPField(field as HTMLElement, options);

      // Maintain Order for rebinds
      this.addField(_field, index);
    });
  }
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
